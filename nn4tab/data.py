# AUTOGENERATED! DO NOT EDIT! File to edit: 01_data.ipynb (unless otherwise specified).

__all__ = ['TabularProc', 'Normalize', 'FillMissing', 'Categorify', 'cont_cat_split', 'TabularDataset', 'get_dsets',
           'get_dl']

# Cell
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split

import torch
from torch import nn
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader

import gc
import typing
from math import isclose
from typing import Sequence, Union, Tuple

# Cell
class TabularProc():
    _order = 1
    isset = False
    def setup(self): pass
    def checkup(self):
        pass
    def encode(self, x):
        raise NotImplementedError
    def decode(self, x): pass

# Cell
class Normalize(TabularProc):
    """
    Normalizes continuous features to zero mean and unit variance.
    """
    def setup(self, df:pd.DataFrame, cont_names:Sequence):
        """Store mean and std for columns in cont_names"""
        self.checkup()
        self.mean = {col: df[col].mean() for col in cont_names}
        self.std = {col: df[col].std() for col in cont_names}
        self.is_set = True

    def encode_one(self, df:pd.DataFrame, col:str):
        return (df[col] - self.mean[col])/self.std[col]

    def encode(self, df:pd.DataFrame, cont_names:Sequence):
        for col in cont_names:
            df[col] = self.encode_one(df, col)

    def decode_one(self, df:pd.DataFrame, col:str):
        return df[col]*self.std[col] + self.mean[col]

    def decode(self, df:pd.DataFrame, cont_names:Sequence):
        for col in cont_names:
            df[col] = self.decode_one(df, col)

# Cell
class FillMissing(TabularProc):
    """Fills missing values in continuous columns"""
    def __init__(self, add_bool=True, method='mean'):
        self.add_bool = add_bool
        self.method = method

    def setup(self, df:pd.DataFrame, cont_names:Sequence, cat_names:Sequence):
        self.checkup()
        if self.method == 'mean':
            self.values = {col:df[col].mean() for col in cont_names}
        self.cont_names = cont_names
        self.cat_names = cat_names
        self.isset = True

    def encode(self, df:pd.DataFrame, cont_names:Sequence=None):
        if not cont_names:
            cont_names = self.cont_names
        for col in cont_names:
            if not df[col].isna().any():
                continue
            if self.add_bool:
                df[f'{col}_na'] = df[col].isna().astype(np.int8)
            df[col].fillna(value=self.values[col], inplace=True)

    def decode(self, *args, **kwargs):
        pass

# Cell
def _catlist(s:pd.Series):
    c = set(s)
    c.discard('#na')
    return ['#na'] + list(c)

# Cell
class Categorify(TabularProc):
    """Numericalizes categorical columns."""
    def setup(self, df:pd.DataFrame, cat_names:Sequence):
        self.checkup()
        self.cat = {col: _catlist(df[col].dropna()) for col in cat_names}
        self.i2c = {c: i for i, c in enumerate(self.cat)}

    def encode_one(self, df:pd.DataFrame, col:str):
        return pd.Series(pd.Categorical(test_df[col].fillna('#na'), categories=self.cat[col])).cat.codes

    def encode(self, df:pd.DataFrame, cat_names:Sequence):
        for col in cat_names:
            df[col] = self.encode_one(df, col)

    def decode_one(self, df:pd.DataFrame, col:str):
        return pd.Series(pd.Categorical.from_codes(df[col], categories=self.cat[col]))

    def decode(self, df:pd.DataFrame, cat_names:Sequence):
        for col in cat_names:
            df[col] = self.decode_one(df, col)

# Cell
def cont_cat_split(df, dep_var=None, max_card=np.inf):
    cont, cat = [], []
    for col in df.columns:
        if col == dep_var: continue #?? mb change to support multiple dep var
        if np.issubdtype(df[col].dtype, np.floating) or (len(df[col].unique()) > max_card and np.issubdtype(df[col].dtype, np.integer)):
            cont.append(col)
        else: #?? any condition np.issubdtype(df[col].dtype, np.integer)
            cat.append(col)
    return cont, cat

# Cell
class TabularDataset(Dataset):

    def __init__(self, df:pd.DataFrame, cat_names:Sequence, cont_names:Sequence, dep_var:Sequence, procs=None):
        self.data = df
        self.cat = cat_names
        self.cont = cont_names
        self.dep_var = dep_var

    def __getitem__(self, idx):
        return (self.data[self.cat].iloc[idx].to_numpy(dtype=np.long),
                self.data[self.cont].iloc[idx].to_numpy(dtype=np.float32),
                self.data[self.dep_var].iloc[idx].to_numpy(dtype=np.float32))

    def __len__(self):
        return len(self.data)

# Cell
def get_dsets(df:pd.DataFrame, cat_names:Sequence, cont_names:Sequence, dep_var:Sequence, splits=None, stratify=True):
    if splits:
        train_df, valid_df = df[splits[0]], df[splits[1]]
    else:
        s = df[dep_var[0]] if stratify else None
        train_df, valid_df = train_test_split(df, test_size=0.2, stratify=s)
    return (TabularDataset(train_df, cat_names, cont_names, dep_var),
            TabularDataset(valid_df, cat_names, cont_names, dep_var))

# Cell
def get_dl(ds, bs=512, train=True, drop_last=True):
    return DataLoader(ds, batch_size=bs, shuffle=train, drop_last=drop_last)